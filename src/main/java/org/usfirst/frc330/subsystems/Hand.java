// RobotBuilder Version: 2.0BB
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc330.subsystems;


import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import org.usfirst.frc330.commands.ManualHand;



import edu.wpi.first.wpilibj.DigitalInput;


// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import org.usfirst.frc330.Robot;
import org.usfirst.frc330.constants.HandConst;
import org.usfirst.frc330.constants.LiftConst;

import org.usfirst.frc330.util.Logger;

import edu.wpi.first.wpilibj.Preferences;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class Hand extends Subsystem {

    boolean lockout = false;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private DigitalInput limitSwitch;
    private WPI_TalonSRX hand;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    boolean calibrated = false;
    int zero = 0;

    public Hand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        limitSwitch = new DigitalInput(6);
        addChild("limitSwitch",limitSwitch);
        
        
        hand = new WPI_TalonSRX(3);
        
        
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        hand.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Absolute, 0, LiftConst.CAN_Timeout);
        hand.setInverted(false); // Set true if the motor direction does not match the sensor direction
        hand.setSensorPhase(false);

        zero = Preferences.getInstance().getInt("HandZero", 0);
        if (zero > 0)
            calibrated = true;
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new ManualHand());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
        SmartDashboard.putNumber("HandZero", zero);
        SmartDashboard.putNumber("HandTicks", hand.getSelectedSensorPosition());
        SmartDashboard.putNumber("HandAngle", ticksToAngle(hand.getSelectedSensorPosition()));
        SmartDashboard.putNumber("HandTicks2", AngletoTicks(ticksToAngle(hand.getSelectedSensorPosition())));
    }

	public void stopHand() {
        hand.disable();
        Logger.getInstance().println("Hand disabled", Logger.Severity.INFO);
        //implemented 2.2.19 -ejo
    }
    
    
    //------------------------
    //      SET METHODS
    //------------------------

	public void setAngle(double angle) {
        //TODO: Implement - AP
    }
    

    //------------------------
    //      GET METHODS
    //------------------------

	public boolean getHandOnTarget() {
        double error = this.getSetpoint() - this.getHandAngle();
      	return (Math.abs(error) < HandConst.tolerance);
	}

	public double getSetpoint() {
        //TODO: Implement - AP
		return (hand.getClosedLoopTarget() - zero) / 4096 * 360.0;
	}

	public double getHandAngle() {
		return (hand.getSelectedSensorPosition() - zero) / 4096 * 360.0;
    }

    public double ticksToAngle(int ticks) {
        return (ticks - zero) / 4096.0 * 360.0 + 57.0;
    }

    public int AngletoTicks(double angle) {
        int ticks = (int)(angle * 4096 /360.0 + 0.5);
        return ticks + zero;
    }
    
    public void calibrate() {
        int newZero = hand.getSelectedSensorPosition();
        calibrated = true;
        Preferences.getInstance().putInt("HandZero", newZero);
        zero = newZero;
    }

	public void engageLockout() {
        this.lockout = true;
	}

	public void disableLockout() {
        this.lockout = false;
    }
    
    public double getHandFirmwareVersion() {
		int firmwareVersion = hand.getFirmwareVersion();
		return ((firmwareVersion & 0xFF00) >> 8) + (firmwareVersion & 0xFF) / 100.0;
    }
    
    public void manualHand() {
        //TODO  verify that axis 3 is the correct axis
		double gamepadCommand = -Robot.oi.gamePad.getRawAxis(3);
    	double position;
    	
    	if (Math.abs(gamepadCommand) > LiftConst.GamepadDeadZone) {
    		this.setThrottle(gamepadCommand/Math.abs(gamepadCommand)*Math.pow(gamepadCommand, 2)*0.4); //scaled to 0.4 max
    	}
    	else if (hand.getControlMode() != ControlMode.Position && hand.getControlMode() != ControlMode.MotionMagic) {
			position = getHandAngle();
			setAngle(position);
    	}  	
    }
    
    public void setThrottle(double output) {
        if(calibrated) {
        	hand.set(ControlMode.PercentOutput, output);
        }
	}

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

}

